/* ***********************************************************************************************************************************
 *
 * Name				: RK4_mod_C_Duffing1989_bifurc_ClDyn_gamma.c
 * Author			: Filipe I. fazanaro
 * Copyright		: The code is released under the GPL v3 license.
 * Email			: filipe.fazanaro at gmail.com
 * Initial Version	: 27/Mar/2015
 * Last Update:		: 17/Jun/2020
 *
 * ***********************************************************************************************************************************
 * DESCRIPTION
 *
 * - Calculation of the Lyapunov global exponents - using the Cloned Dynamics approach - for the forced Duffing
 * oscillator dynamical system [1,2].
 *
 * - Control parameters: 'gamma'.
 *
 * - Employs the fourth-order Runge-Kutta integrator.
 *
 * - Employs separated functions for the dynamical systems, RK4 integration.
 *
 * ***********************************************************************************************************************************
 * OBSERVATIONS
 *
 * - To be done:
 * 		 - Implement separated functions for the Gram-Schimidt Reorthonormalization.
 *
 * ***********************************************************************************************************************************
 * PROPOSITIONS
 * 	- This source code employs memory allocation. When nIncParam is too small (as 0.001), it will result in "segmentation fault".
 * 		- It is explained such as: when the 2D array is too large, it will "overflow" the computer stack. So, it is necessary
 * 		to move the data to the "free memory" region.
 *
 * 	- Possible solutions: [13,14]
 *
 * ***********************************************************************************************************************************
 * REFERENCES
 * [1] Parker and Chua (1989) Practical Numerical algorithms for Chaotic Systems. Springer-Verlag.
 *
 * [2] Guckenheimer, Holmes (2002) Nonlinear Oscillations, Dynamical Systems, and Bifurcations of Vector Fields.
 * Springer. 2nd edition.
 *
 * [3] http://mmae.iit.edu/shadden/LCS-tutorial/overview.html
 *
 * [4] Wolf, Swift, Swinney, Vastano (1985) Determining Lyapunov exponents from time series, Physica 16D, pp 285-317.
 * DOI:10.1016/0167-2789(85)90011-9
 *
 * [5] Soriano, Fazanaro, Suyama, JRO, Attux and Madrid (2012) A method for Lyapunov spectrum estimation using
 * cloned dynamics and its application toÂ the discontinuously-excited FitzHugh-Nagumo model. Nonlinear Dynamics,
 * vol 67, no 1, pp 413-424. DOI: 10.1007/s11071-011-9989-2.
 *
 * [6] https://www.google.com/search?q=error%3A+constant+value+is+not+known+CUDA&ie=UTF-8&sa=Search&channel=fe&client=browser-ubuntu&hl=en
 *
 * [7] http://stackoverflow.com/questions/9936376/how-to-defined-a-cuda-shared-memory-with-a-size-known-at-run-time
 *
 * [8] http://stackoverflow.com/questions/5531247/allocating-shared-memory/5531640#5531640
 *
 * [9] How to define square waves in C:
 * http://stackoverflow.com/questions/1073606/is-there-a-one-line-function-that-generates-a-triangle-wave
 *
 * [10] Most important characteristics of GPUs
 * http://developer.download.nvidia.com/compute/cuda/4_1/rel/toolkit/docs/online/group__CUDART__DEVICE_g5aa4f47938af8276f08074d09b7d520c.html
 *
 * [11] MEASURING TIME
 * http://ivanlife.wordpress.com/2011/05/09/time-cuda/
 * http://devblogs.nvidia.com/parallelforall/how-implement-performance-metrics-cuda-cc/
 *
 * [12] Pearson product-moment correlation coefficient
 * http://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient
 *
 * [13] http://stackoverflow.com/questions/13677566/malloc-a-2d-array-in-c
 *
 * [14] http://stackoverflow.com/questions/1970698/using-malloc-for-allocation-of-multi-dimensional-arrays-with-different-row-lengt
 *
 * ***********************************************************************************************************************************
 */


/* ******************************************************************************************************************************** */
// includes, system

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <time.h>


/* ******************************************************************************************************************************** */
/* DEFINITIONS ******************************************************************************************************************** */
/* ******************************************************************************************************************************** */

#define pi 3.141592653589793238462643383


/* ******************************************************************************************************************************** */
/* IMPORTANT DEFINITIONS: DYNAMICAL SYSTEMS DIMENSIONS **************************************************************************** */
/* ******************************************************************************************************************************** */

#define dim 3

#define dim_total dim*(dim+1)

/* ******************************************************************************************************************************** */



/* ******************************************************************************************************************************** */
/* 												RUNGE KUTTA FOURTH ORDER INTEGRATOR													*/
/* ******************************************************************************************************************************** */
double odeRK4( double(*odefun)(double *, double, double *, double *), double * dydt, double h, double t0, double * y_init, double * vParameters, int nIntegra )
{

	// ============================================================================================================================ //
	// INITIALIZATIONS ============================================================================================================= //
	// ============================================================================================================================ //

	double Y0[dim_total];

	double k1[dim_total];
	double k2[dim_total];
	double k3[dim_total];
	double k4[dim_total];

	double t = t0;

	// ============================================================================================================================ //
	// MAIN LOOP ================================================================================================================== //
	// ============================================================================================================================ //
	for( unsigned int idx_Integra = 0; idx_Integra < nIntegra; idx_Integra++ )
	{

		// ------------------------------------------------------------------------------------------------------------------------ //
		// PARAMETER: k1 ---------------------------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		odefun( k1, t, y_init, vParameters );

		for( unsigned int jj = 0; jj < dim_total; jj++ )
		{

			k1[jj] = h*k1[jj];

			// Debug
			//printf("k1[%d] = %.6f\n", jj, k1[jj]);

		}

		//printf("\n");


		// ------------------------------------------------------------------------------------------------------------------------ //
		// PARAMETER: k2 ---------------------------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		for( unsigned int jj = 0; jj < dim_total; jj++ )
		{

			Y0[jj] = y_init[jj] + k1[jj]/2.0;

			// Debug
			//printf("Y0[%d] = %.6f\n", jj, Y0[jj]);

		}

		//printf("\n");


		odefun( k2, t, Y0, vParameters );

		for( unsigned int jj = 0; jj < dim_total; jj++ )
		{

			k2[jj] = h*k2[jj];

			// Debug
			//printf("k2[%d] = %.6f\n", jj, k2[jj]);

		}

		//printf("\n");



		// ------------------------------------------------------------------------------------------------------------------------ //
		// PARAMETER: k3 ---------------------------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		for( unsigned int jj = 0; jj < dim_total; jj++ )
		{

			Y0[jj] = y_init[jj] + k2[jj]/2.0;

			// Debug
			//printf("Y0[%d] = %.6f\n", jj, Y0[jj]);

		}

		//printf("\n");


		odefun( k3, t, Y0, vParameters );

		for( unsigned int jj = 0; jj < dim_total; jj++ )
		{

			k3[jj] = h*k3[jj];

			// Debug
			//printf("k3[%d] = %.6f\n", jj, k3[jj]);

		}

		//printf("\n");


		// ------------------------------------------------------------------------------------------------------------------------ //
		// PARAMETER: k4 ---------------------------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		for( unsigned int jj = 0; jj < dim_total; jj++ )
		{

			Y0[jj] = y_init[jj] + k3[jj];

			// Debug
			//printf("Y0[%d] = %.6f\n", jj, Y0[jj]);

		}

		//printf("\n");


		odefun( k4, t, Y0, vParameters );

		for( unsigned int jj = 0; jj < dim_total; jj++ )
		{

			k4[jj] = h*k4[jj];

			// Debug
			//printf("k4[%d] = %.6f\n", jj, k4[jj]);

		}

		//printf("\n");


		// ------------------------------------------------------------------------------------------------------------------------ //
		// UPDATE THE INITIAL CONDITIONS FOR THE NEXT ITERATION ------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		for( unsigned int jj = 0; jj < dim_total; jj++ )
		{

			y_init[jj] = y_init[jj] + (1/6.0)*( k1[jj] + 2.0*k2[jj] + 2.0*k3[jj] + k4[jj] );

			// Debug
			//printf("y_init[%d] = %.6f\n", jj, y_init[jj]);
			//printf("[%.6f]", y_init[jj]);

		}

		//printf("\n");


		// ------------------------------------------------------------------------------------------------------------------------ //
		// UPDATE THE TIME STEP --------------------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		// Debug
		//printf("t = %.6f\n\n", t);

		t += h;

		// Debug
		//printf("t = %.6f\n\n", t);


	} // END MAIN LOOP
	// ============================================================================================================================ //


	// ============================================================================================================================ //
	// RETURN THE INTEGRAION RESULTS ============================================================================================== //
	// ============================================================================================================================ //

	//printf("\n");

	for( unsigned int jj = 0; jj < dim_total; jj++ )
	{

		dydt[jj] = y_init[jj];

		// Debug
		//printf("y_init[%d] = %.6f\n", jj, y_init[jj]);
		//printf("[%.6f]", y_init[jj]);

	}

	//printf("\n");

	// ============================================================================================================================ //

	return 0;

	// ============================================================================================================================ //

}
/* ******************************************************************************************************************************** */



/* ******************************************************************************************************************************** */
/* 															ODEFUN																	*/
/* ******************************************************************************************************************************** */
double odefun_Duffing1989_ClDyn( double * dydt, double t0, double * y_init, double * vParameters )
{


	// ============================================================================================================================ //
	// PARAMETERS ================================================================================================================= //
	// ============================================================================================================================ //

	double epsilon = vParameters[0];
	double gamma   = vParameters[1];
	double omega   = vParameters[2];


	// ============================================================================================================================ //
	// INITIAL CONDITIONS ========================================================================================================= //
	// ============================================================================================================================ //

	// DYNAMIC MODEL - FIDUCIAL

	double y10 = y_init[0];
	double y20 = y_init[1];
	double y30 = y_init[2];


	// DYNAMIC MODEL - CLONES

	double y40 = y_init[3];
	double y50 = y_init[4];
	double y60 = y_init[5];

	double y70 = y_init[6];
	double y80 = y_init[7];
	double y90 = y_init[8];

	double y100 = y_init[9];
	double y110 = y_init[10];
	double y120 = y_init[11];


	// ============================================================================================================================ //
	// DYNAMIC MODEL ============================================================================================================== //
	// ============================================================================================================================ //

	// ----------------------------------------------------------------------- //
	// DYNAMICAL SYSTEM - ORIGINAL (or FIDUCIAL) ----------------------------- //
	// ----------------------------------------------------------------------- //

	dydt[0] = y20;
	dydt[1] = y10 - pow(y10,3) - epsilon*y20 + gamma*cos( omega*y30 );
	dydt[2] = 1.0;


	// ----------------------------------------------------------------------- //
	// DYNAMICAL SYSTEM - CLONES --------------------------------------------- //
	// ----------------------------------------------------------------------- //

	dydt[3] = y70;
	dydt[4] = y80;
	dydt[5] = y90;

	dydt[6] = y40 - pow(y40,3) - epsilon*y70 + gamma*cos( omega*y100 );
	dydt[7] = y50 - pow(y50,3) - epsilon*y80 + gamma*cos( omega*y110 );
	dydt[8] = y60 - pow(y60,3) - epsilon*y90 + gamma*cos( omega*y120 );

	dydt[9]  = 1.0;
	dydt[10] = 1.0;
	dydt[11] = 1.0;

	// ============================================================================================================================ //

	return 0;

	// ============================================================================================================================ //


}
/* ******************************************************************************************************************************** */






/* ******************************************************************************************************************************** */
/* ******************************************************************************************************************************** */
/* 															MAIN FUNCTION															*/
/* ******************************************************************************************************************************** */
/* ******************************************************************************************************************************** */
int main()
{

	/* **************************************************************************************************************************** */
	/* AUX ************************************************************************************************************************ */
	/* **************************************************************************************************************************** */

	unsigned int idxIterations = 0;

	//unsigned int idxIntegra = 0;


	unsigned int idxCounterControlParameters = 0;


	// Writing to the disk:
	//		1-) Control parameter 1 = epsilon
	//		2-) others parameters   = omega, gamma
	//		3-) Lyap1, Lyap2, Lyap3
	//		4-) tItera
	unsigned int numExtraSaves = 4;


	/* **************************************************************************************************************************** */
	/* PARAMETERS ***************************************************************************************************************** */
	/* **************************************************************************************************************************** */

	const double epsilon = 0.25;

	const double omega 	 = 1.0;


	/* **************************************************************************************************************************** */
	/* CONTROL PARAMETERS ********************************************************************************************************* */
	/* **************************************************************************************************************************** */

	double gamma;


	// ---------------------------------------------------------------------------------------------------------------------------- //
	// VARIATION STEP OF THE CONTROL PARAMETERS ----------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //
	double nIncControlParameter1 = 0.05;


	// ---------------------------------------------------------------------------------------------------------------------------- //
	// CONTROL PARAMETER VECTOR CONSTRUCTION -------------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //
	double vGamma_min = 0.1;
	double vGamma_max = 0.3;


	int vGamma_length = round( ((vGamma_max - vGamma_min)/nIncControlParameter1) + 1 );


	double vGamma[vGamma_length];



	for ( unsigned int ii = 0; ii < vGamma_length; ii++ )
	{
		if (ii == 0)
			vGamma[ii] = vGamma_min;

		else
			vGamma[ii] = vGamma[ii-1] + nIncControlParameter1;

		// ------------------------------------------------------ //
		// DEBUG - SCREEN --------------------------------------- //
		// ------------------------------------------------------ //

		//printf("vGamma[%d] = %.6f\n", ii, vGamma[ii]);

		// ------------------------------------------------------ //

	}

	//printf( "\n" );


	// ---------------------------------------------------------------------------------------------------------------------------- //
	// HOW MANY COMBINATONS ------------------------------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	printf("\n Control parameters combinations = %.d\n", (vGamma_length) );

	// ---------------------------------------------------------------------------------------------------------------------------- //


	/* **************************************************************************************************************************** */
	/* INITIAL CONDITIONS OF THE DYNAMICAL AND THE CLONED SYSTEMS ***************************************************************** */
	/* **************************************************************************************************************************** */

	// Initial time
	const double t_init = 0.0;

	//	// Aux
	//	double t_aux = 0.0;

	// Final time
	const double t_final = 10000.0;


	// Gram-Schimidt reorthonormalization time interval
	//   - See [5] for further details related to how to change this value.
	const double t_gsr = 0.5;


	// Time step
	const double h = 0.01;


	// Maximum iteration number
	const int nMaxItera = round( (t_final - t_init) / t_gsr );
	//printf("\n nMaxItera = %d\n", nMaxItera);
	printf("\n nMaxItera per combination = %d\n", nMaxItera);

	// Defines how many iterations of the RK4 algorithm will be executed every iteration
	const int nIntegra = round( t_gsr / h );
	//printf("\n nIntegra = %d\n\n", nIntegra);
	printf("\n nIntegra per iteration = %d\n", nIntegra);

	// Defines the total number of iterations
	const int n = nMaxItera*nIntegra;
	printf("\n Total number of iterations per combination = %d\n", n);


	printf("\n\n");


	//	/* **************************************************************************************************************************** */
	//	/* GRAM-SCHIMIDT REORTHONORMALIZATION ***************************************************************************************** */
	//	/* **************************************************************************************************************************** */
	//
	//	double vk[dim][dim];
	//	double uk[dim][dim];
	//
	//	double deltax[dim][dim];
	//
	//
	//	for( unsigned int ii = 0; ii < dim; ii++ )
	//	{
	//		for( unsigned int jj = 0; jj < dim; jj++ )
	//		{
	//			vk[ii][jj] = 0.0;
	//			uk[ii][jj] = 0.0;
	//
	//			deltax[ii][jj] = 0.0;
	//		}
	//	}


	/* **************************************************************************************************************************** */
	/* LYAPUNOV EXPONENTS INITIALIZATIONS ***************************************************************************************** */
	/* **************************************************************************************************************************** */

	// ---------------------------------------------------------------------------------------------------------------------------- //
	// OBSERVATION:
	//	- [Jan 20, 2015]:
	//		- If this 2D array is too large, then it will "overflow" the stack, causign the "segmentation fault".
	//		- References:
	//			http://stackoverflow.com/questions/851122/large-2d-array-gives-segmentation-fault
	//			http://stackoverflow.com/questions/13677566/malloc-a-2d-array-in-c
	//			http://stackoverflow.com/questions/1970698/using-malloc-for-allocation-of-multi-dimensional-arrays-with-different-row-lengt
	// ---------------------------------------------------------------------------------------------------------------------------- //
	// Organization:
	//	- [Control parameter1][Control parameter2][Lyap1][Lyap2][Lyap3][Lyap4][Mean Square Error - Driver - Response][Mean Square Error - Error][Rho][Rho_trans]
	// ---------------------------------------------------------------------------------------------------------------------------- //

	int nRows = (vGamma_length);
	int nCols = dim+numExtraSaves;

	double **Mz_Lyap;

	Mz_Lyap = malloc( (nRows) * sizeof(double *) );


	//	for ( unsigned int ii = 0; ii < nRows; ii++ )
	//		Mz_Lyap[ii] = malloc( nCols * sizeof(double) );

	// Trying to protect the system
	for ( unsigned int ii = 0; ii < nRows; ii++ )
		if( !( Mz_Lyap[ii] = malloc( nCols * sizeof(double) ) ) )
		{
			printf( "Error: out of memory!!!\n\n" );
			exit(1);
		}


	// ---------------------------------------------------------------------------------------------------------------------------- //

	double LyapSoma[dim];
	double Lyap[dim];


	//	// Array initialization
	//	for( unsigned int ii = 0; ii < dim; ii++ )
	//	{
	//			LyapSoma[ii][0] = 0.0;
	//			Lyap[ii][0] = 0.0;
	//	}


	// ---------------------------------------------------------------------------------------------------------------------------- //
	// Uncomment if you want to save the data points ------------------------------------------------------------------------------ //
	// ---------------------------------------------------------------------------------------------------------------------------- //
	//double Time[nMaxItera];

	//Time[0] = 0.0;


	/* **************************************************************************************************************************** */
	/* POINTERS USED TO SAVA DATA ON DISK ***************************************************************************************** */
	/* **************************************************************************************************************************** */

	// ---------------------------------------------------------------------------------------------------------------------------- //
	// TEMPORAL CHARACTERISTICS AND SOME OTHER THINGS ----------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	FILE *fileData_Header = fopen("data_C_RK4_mod_Duffing1989_bifurc_ClDyn_Header.dat", "w+");


	// ---------------------------------------------------------------------------------------------------------------------------- //
	// LYAPUNOV EXPONENTS - Mz MATRIZ --------------------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	FILE *fileData_Mz_Lyap = fopen("data_C_RK4_mod_Duffing1989_bifurc_ClDyn_Gamma.dat", "w+");

	// ---------------------------------------------------------------------------------------------------------------------------- //

	if (fileData_Header == NULL)
	{
		printf(" Error opening the file 'data_C_RK4_mod_Duffing1989_bifurc_ClDyn_Header.dat' !\n");
		exit(1);
	}


	if (fileData_Mz_Lyap == NULL)
	{
		printf(" Error opening the file 'data_C_RK4_mod_Duffing1989_bifurc_ClDyn_Gamma.dat' !\n");
		exit(1);
	}

	// ---------------------------------------------------------------------------------------------------------------------------- //


	/* **************************************************************************************************************************** */
	/* PUT SOME STRINGS AT THE BEGINNING OF THE DATA FILES ************************************************************************ */
	/* **************************************************************************************************************************** */

	fprintf( fileData_Mz_Lyap, "#epsilon, gamma, omega, lambda1, lambda2, lambda3, tItera\n" );


	/* **************************************************************************************************************************** */
	/* MEASURING THE TOTAL COMPUTATIONAL TIME - BEGINS **************************************************************************** */
	/* **************************************************************************************************************************** */

	clock_t start = clock() ;


	/* **************************************************************************************************************************** */
	/* INITIATES THE MAIN LOOP - CONTROL PARAMETER 1 ****************************************************************************** */
	/* **************************************************************************************************************************** */

	for( unsigned int idx_vGamma = 0; idx_vGamma < vGamma_length; idx_vGamma++ )
	{


		// ------------------------------------------------------------------------------------------------------------------------ //
		// INITIALIZATION - AUX VARIABLES ----------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //
		idxIterations = 0;

		//idxIntegra = 0;


		//* *********************************************************************************************************************** */
		/* MEASURING THE COMPUTATIONAL TIME FOR EACH ITERATION ******************************************************************** */
		//* *********************************************************************************************************************** */

		clock_t start_Iteration = clock();


		//* *********************************************************************************************************************** */
		/* CONTROL PARAMETERS ***************************************************************************************************** */
		//* *********************************************************************************************************************** */

		gamma = vGamma[idx_vGamma];

		printf( "gamma = %.6f  ", gamma );


		//* *********************************************************************************************************************** */
		/* CONTROL PARAMETER VECTOR *********************************************************************************************** */
		//* *********************************************************************************************************************** */

		double vParameters[] = { epsilon, gamma, omega };


		//* *********************************************************************************************************************** */
		/* IMPORTANT INITIALIZATIONS ********************************************************************************************** */
		//* *********************************************************************************************************************** */

		// Time aux
		double t_aux = 0.0;

		unsigned int aux_counter = 0;

		//unsigned int idxCounterNumIterations = 0;


		//* *********************************************************************************************************************** */
		/* GRAM-SCHIMIDT REORTHONORMALIZATION ************************************************************************************* */
		//* *********************************************************************************************************************** */

		double vk[dim][dim];
		double uk[dim][dim];

		double deltax[dim][dim];


		for( unsigned int ii = 0; ii < dim; ii++ )
		{
			for( unsigned int jj = 0; jj < dim; jj++ )
			{
				vk[ii][jj] = 0.0;
				uk[ii][jj] = 0.0;

				deltax[ii][jj] = 0.0;
			}
		}


		//* *********************************************************************************************************************** */
		/* INITIAL CONDITIONS OF THE DYNAMICAL AND THE CLONED SYSTEMS ************************************************************* */
		//* *********************************************************************************************************************** */

		// ------------------------------------------------------------------------------------------------------------------------ //
		// CLONED DYNAMICAL SYSTEM PERTURBATION - SEE [5] ------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		const double delta = 0.0001;


		// ------------------------------------------------------------------------------------------------------------------------ //
		// ORIGINAL SYSTEM -------------------------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		double
		vX0 = 1.0,
		vY0 = 1.0,
		vZ0 = 0.0;


		double y_init_orig[] = { vX0, vY0, vZ0 };


		// ------------------------------------------------------------------------------------------------------------------------ //
		// PERTURBATION MATRIX ---------------------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		// IDENTITY MATRIX
		double mIdentity[dim][dim];

		for ( unsigned int idxRows = 0; idxRows < dim; idxRows++)
			for ( unsigned int idxCols = 0; idxCols < dim; idxCols++)
			{

				if ( idxCols == idxRows )
					mIdentity[idxRows][idxCols] = delta;
				else
					mIdentity[idxRows][idxCols] = 0.0;


				// Debug
				//printf( "mIdentity[%d][%d] = %.6f\n", idxRows, idxCols, mIdentity[idxRows][idxCols] );

			}


		// 2D array to 1D array transformation

		int HEIGHT = dim;
		int WIDTH  = dim;

		double y_init_perturb[HEIGHT * WIDTH];

		for ( unsigned int idxHEIGHT = 0; idxHEIGHT < HEIGHT; idxHEIGHT++)
		{

			for ( unsigned int idxWIDTH = 0; idxWIDTH < WIDTH; idxWIDTH++)
			{

				y_init_perturb[idxHEIGHT*WIDTH + idxWIDTH]= mIdentity[idxHEIGHT][idxWIDTH] + y_init_orig[idxHEIGHT];

				// Debug
				//printf( "[y_init_perturb[%d] = %.6f]", (idxHEIGHT*WIDTH + idxWIDTH), y_init_perturb[idxHEIGHT*WIDTH + idxWIDTH] );

			}

			//printf( "\n" );

		}

		//printf( "\n\n" );


		// ------------------------------------------------------------------------------------------------------------------------ //
		// COMPLETE SYSTEM -------------------------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		//printf( "\n\n" );


		double y_init[dim_total];


		for( unsigned int ii = 0; ii < dim_total; ii++){
			if( ii < dim ){

				y_init[ii] = y_init_orig[aux_counter];

				aux_counter++;

			}else{

				if( ii == dim )
					aux_counter = 0;

				y_init[ii] = y_init_perturb[aux_counter];

				aux_counter++;

			}

			// ------------------------------------------------------------------ //
			// INITIAL CONDITIONS DEBUG
			// ------------------------------------------------------------------ //

			//printf("y_init[%d] = %.6f\n", ii, y_init[ii]);

			// ------------------------------------------------------------------ //

		}

		//printf("\n\n");


		//* *********************************************************************************************************************** */
		/* ARRAY INITIALIZAION **************************************************************************************************** */
		//* *********************************************************************************************************************** */

		for( unsigned int ii = 0; ii < dim; ii++ )
		{

			// -------------------------------------------------------------------------------------------------------------------- //
			// LYAPUNOV EXPONENTS ------------------------------------------------------------------------------------------------- //
			// -------------------------------------------------------------------------------------------------------------------- //
			LyapSoma[ii] = 0.0;
			Lyap[ii] = 0.0;

		}


		//* *********************************************************************************************************************** */
		/* DYNAMICAL SYSTEM INTEGRATION ******************************************************************************************* */
		//* *********************************************************************************************************************** */

		while (idxIterations < nMaxItera) {

			/* ==================================================================================================================== */
			/* DYNAMICAL SYSTEM INTEGRATION ======================================================================================= */
			/* ==================================================================================================================== */

			double dydt[dim_total];


			odeRK4( odefun_Duffing1989_ClDyn, dydt, h, t_aux, y_init, vParameters, nIntegra );


			/* ==================================================================================================================== */
			/* AUXILIAR TIME "STEP" ATUALIZATION ================================================================================== */
			/* ==================================================================================================================== */

			t_aux = t_aux + t_gsr;


			/* ==================================================================================================================== */
			/* DIFERENCE STATE VECTORS ============================================================================================ */
			/* ==================================================================================================================== */

			// ------------------------------------------------------------------------------------ //
			// THE DUMMY WAY ---------------------------------------------------------------------- //
			// ------------------------------------------------------------------------------------ //

			//		deltax[0][0] = dydt[0] - dydt[3];
			//		deltax[0][1] = dydt[0] - dydt[4];
			//		deltax[0][2] = dydt[0] - dydt[5];
			//
			//		deltax[1][0] = dydt[1] - dydt[6];
			//		deltax[1][1] = dydt[1] - dydt[7];
			//		deltax[1][2] = dydt[1] - dydt[8];
			//
			//		deltax[2][0] = dydt[2] - dydt[9];
			//		deltax[2][1] = dydt[2] - dydt[10];
			//		deltax[2][2] = dydt[2] - dydt[11];


			// ------------------------------------------------------------------------------------ //
			// TRYING A BETTER WAY ---------------------------------------------------------------- //
			// ------------------------------------------------------------------------------------ //

			for( unsigned int idxRows = 0; idxRows < dim; idxRows++ )
			{
				for( unsigned int idxCols = 0; idxCols < dim; idxCols++ )
				{
					deltax[idxRows][idxCols] = dydt[idxRows] - dydt[dim*(idxRows+1)+idxCols];
				}
			}


			// ------------------------------------------------------------------------------------ //
			// DEBUG - SCREEN --------------------------------------------------------------------- //
			// ------------------------------------------------------------------------------------ //

			//		printf( "\n" );
			//
			//		for( unsigned int ii = 0; ii < dim; ii++ )
			//		{
			//			for( unsigned int jj = 0; jj < dim; jj++ )
			//			{
			//				//printf( "[deltax[%d][%d] = %.6f]", ii, jj, deltax[ii][jj] );
			//				printf( "[%.12f]", deltax[ii][jj] );
			//			}
			//			printf( "\n" );
			//		}
			//
			//		printf( "\n" );


			/* ==================================================================================================================== */
			/* GRAM-SCHIMIDT REORTHONORMALIZATION ================================================================================= */
			/* ==================================================================================================================== */

			// ------------------------------------------------------------------------------------ //
			// THE DUMMY WAY ---------------------------------------------------------------------- //
			// ------------------------------------------------------------------------------------ //

			double pdi1 = 0.0;
			double pdi2 = 0.0;

			double Norm1 = 0.0;
			double Norm2 = 0.0;
			double Norm3 = 0.0;


			// EXPONENT Lyap1
			vk[0][0] = deltax[0][0];
			vk[1][0] = deltax[1][0];
			vk[2][0] = deltax[2][0];

			Norm1 = sqrt( pow(vk[0][0],2)+pow(vk[1][0],2)+pow(vk[2][0],2) );

			uk[0][0] = vk[0][0]/Norm1;
			uk[1][0] = vk[1][0]/Norm1;
			uk[2][0] = vk[2][0]/Norm1;


			// EXPONENT Lyap2
			// 	- Remember: the numerator represents a dot product
			//	- Remember: the denumerator represents the square of each element of the vector
			pdi1 = ( uk[0][0]*deltax[0][1]+uk[1][0]*deltax[1][1]+uk[2][0]*deltax[2][1] ) / ( uk[0][0]*uk[0][0]+uk[1][0]*uk[1][0]+uk[2][0]*uk[2][0] );

			vk[0][1] = deltax[0][1] - pdi1 * uk[0][0];
			vk[1][1] = deltax[1][1] - pdi1 * uk[1][0];
			vk[2][1] = deltax[2][1] - pdi1 * uk[2][0];

			Norm2 = sqrt( pow(vk[0][1],2)+pow(vk[1][1],2)+pow(vk[2][1],2) );

			uk[0][1] = vk[0][1]/Norm2;
			uk[1][1] = vk[1][1]/Norm2;
			uk[2][1] = vk[2][1]/Norm2;


			// EXPONENT Lyap3
			pdi1 = ( uk[0][0]*deltax[0][2]+uk[1][0]*deltax[1][2]+uk[2][0]*deltax[2][2] ) / ( uk[0][0]*uk[0][0]+uk[1][0]*uk[1][0]+uk[2][0]*uk[2][0] );
			pdi2 = ( uk[0][1]*deltax[0][2]+uk[1][1]*deltax[1][2]+uk[2][1]*deltax[2][2] ) / ( uk[0][1]*uk[0][1]+uk[1][1]*uk[1][1]+uk[2][1]*uk[2][1] );

			vk[0][2] = deltax[0][2] - pdi1*uk[0][0] - pdi2*uk[0][1];
			vk[1][2] = deltax[1][2] - pdi1*uk[1][0] - pdi2*uk[1][1];
			vk[2][2] = deltax[2][2] - pdi1*uk[2][0] - pdi2*uk[2][1];

			Norm3 = sqrt( pow(vk[0][2],2)+pow(vk[1][2],2)+pow(vk[2][2],2) );

			uk[0][2] = vk[0][2]/Norm3;
			uk[1][2] = vk[1][2]/Norm3;
			uk[2][2] = vk[2][2]/Norm3;


			//		// ------------------------------------------------------------------------------------ //
			//		// DEBUG - SCREEN - vk ---------------------------------------------------------------- //
			//		// ------------------------------------------------------------------------------------ //
			//
			//		printf( "\n" );
			//
			//		for( unsigned int ii = 0; ii < dim; ii++ )
			//		{
			//			for( unsigned int jj=0; jj < dim; jj++ )
			//			{
			//				//printf( "| vk[%d][%d] = %.12f |", ii, jj, vk[ii][jj] );
			//				printf( "[%.12f]", vk[ii][jj] );
			//			}
			//
			//			//printf( "|\n" );
			//			printf( "\n" );
			//		}
			//
			//		printf( "\n" );
			//
			//
			//		// ------------------------------------------------------------------------------------ //
			//		// SCREEN - uk ------------------------------------------------------------------------ //
			//		// ------------------------------------------------------------------------------------ //
			//
			//		printf( "\n" );
			//
			//		for( unsigned int ii = 0; ii < dim; ii++ )
			//		{
			//			for( unsigned int jj=0; jj < dim; jj++ )
			//			{
			//				//printf( "| uk[%d][%d] = %.12f |", ii, jj, uk[ii][jj] );
			//				printf( "[%.12f]", uk[ii][jj] );
			//			}
			//
			//			//printf( "|\n" );
			//			printf( "\n" );
			//		}
			//
			//		printf( "\n" );


			/* ==================================================================================================================== */
			/* LYAPUNOV EXPONENTS CALCULATION ===================================================================================== */
			/* ==================================================================================================================== */

			// -------------------------------------------------------------------------------------------------------------------- //
			// LYAPUNOV EXPONENTS SUMMATION --------------------------------------------------------------------------------------- //
			// -------------------------------------------------------------------------------------------------------------------- //

			LyapSoma[0] = LyapSoma[0] + log( Norm1 / delta );
			LyapSoma[1] = LyapSoma[1] + log( Norm2 / delta );
			LyapSoma[2] = LyapSoma[2] + log( Norm3 / delta );


			// -------------------------------------------------------------------------------------------------------------------- //
			// SCREEN ------------------------------------------------------------------------------------------------------------- //
			// -------------------------------------------------------------------------------------------------------------------- //

			//		printf( "\n" );
			//
			//		for( unsigned int ii = 0; ii < dim; ii++ )
			//		{
			//			for( unsigned int jj = 0; jj <= (idxIterations+1); jj++ )
			//			{
			//				//printf( "| LyapSoma[%d][%d] = %.8f | ", ii, jj, LyapSoma[ii][jj] );
			//				printf( "[%.12f]", LyapSoma[ii][jj] );
			//			}
			//			printf( "\n" );
			//		}
			//
			//		printf( "\n" );


			/* ==================================================================================================================== */
			/* PREPARE FOR THE NEXT ITERATION ===================================================================================== */
			/* ==================================================================================================================== */

			// -------------------------------------------------------------------------------------------------------------------- //
			// INITIAL CONDITIONS - THE DUMMY WAY --------------------------------------------------------------------------------- //
			// -------------------------------------------------------------------------------------------------------------------- //

			// ORIGINAL SYSTEM
			y_init[0] = dydt[0];
			y_init[1] = dydt[1];
			y_init[2] = dydt[2];

			// CLONES
			y_init[3] = dydt[0] + delta*uk[0][0];
			y_init[4] = dydt[0] + delta*uk[0][1];
			y_init[5] = dydt[0] + delta*uk[0][2];

			y_init[6] = dydt[1] + delta*uk[1][0];
			y_init[7] = dydt[1] + delta*uk[1][1];
			y_init[8] = dydt[1] + delta*uk[1][2];

			y_init[9]  = dydt[2] + delta*uk[2][0];
			y_init[10] = dydt[2] + delta*uk[2][1];
			y_init[11] = dydt[2] + delta*uk[2][2];

			// -------------------------------------------------------------------------------------------------------------------- //

			//Time[idxIterations+1] = t_aux;

			// -------------------------------------------------------------------------------------------------------------------- //

			idxIterations++;

			//idxIntegra = 0;

			// -------------------------------------------------------------------------------------------------------------------- //

			/* ==================================================================================================================== */

		} // END - ITERATIONS
		//* *********************************************************************************************************************** */



		//* *********************************************************************************************************************** */
		/* GLOBAL LYAPUNOV EXPONENTS ********************************************************************************************** */
		//* *********************************************************************************************************************** */

		Lyap[0] = LyapSoma[0] / (double)(t_final - t_init);
		Lyap[1] = LyapSoma[1] / (double)(t_final - t_init);
		Lyap[2] = LyapSoma[2] / (double)(t_final - t_init);


		// ------------------------------------------------------------------------------------------------------------------------ //
		// SCREEN - LYAPUNOV EXPONENTS OBTAINED AT THE END OF EACH ITERATION ------------------------------------------------------ //
		// ------------------------------------------------------------------------------------------------------------------------ //

		for( unsigned int ii = 0; ii < dim; ii++ )
			printf("Lyap[%d] = %.6f  ", ii, Lyap[ii]);

		printf( " " );


		//* *********************************************************************************************************************** */
		/* MEASURING THE ITERATION TOTAL COMPUTATIONAL TIME *********************************************************************** */
		//* *********************************************************************************************************************** */

		clock_t end_Iteration = clock() ;

		double elapsed_time_Iteration = (end_Iteration-start_Iteration)/(double)CLOCKS_PER_SEC ;

		//printf( "\n" );

		printf( " Elapsed time [s]: %.12f \n", elapsed_time_Iteration );


		//* *********************************************************************************************************************** */
		/* STORE: CONTROL PARAMETERS, LYAPUNOV EXPONENTS AND ITERATION TIME ******************************************************* */
		//* *********************************************************************************************************************** */

		for( unsigned int idx_storeLyap = 0; idx_storeLyap < (dim+numExtraSaves); idx_storeLyap++ )
		{

			if( idx_storeLyap == 0 )
			{
				Mz_Lyap[idxCounterControlParameters][idx_storeLyap] = epsilon;
				//printf("Mz_Lyap[%d][%d] = %.6f\n", idxCounterControlParameters, idx_storeLyap, Mz_Lyap[idxCounterControlParameters][idx_storeLyap]);	// screen - debug
			}

			else if( idx_storeLyap == 1 )
			{
				Mz_Lyap[idxCounterControlParameters][idx_storeLyap] = gamma;
				//printf("Mz_Lyap[%d][%d] = %.6f\n", idxCounterControlParameters, idx_storeLyap, Mz_Lyap[idxCounterControlParameters][idx_storeLyap]);	// screen - debug
			}

			else if( idx_storeLyap == 2 )
			{
				Mz_Lyap[idxCounterControlParameters][idx_storeLyap] = omega;
				//printf("Mz_Lyap[%d][%d] = %.6f\n", idxCounterControlParameters, idx_storeLyap, Mz_Lyap[idxCounterControlParameters][idx_storeLyap]);	// screen - debug
			}

			else if( (idx_storeLyap >= 3)&&(idx_storeLyap < (dim+numExtraSaves-1)) )
			{
				Mz_Lyap[idxCounterControlParameters][idx_storeLyap] = Lyap[idx_storeLyap-numExtraSaves+1];
				//printf("Mz_Lyap[%d][%d] = %.6f\n", idx_vEpsilon, idx_storeLyap, Lyap[idx_storeLyap-1]); // screen - debug
			}

			else //if( (idx_storeLyap >= (dim+numExtraSaves)) )
			{
				Mz_Lyap[idxCounterControlParameters][idx_storeLyap] = elapsed_time_Iteration;
			}

		}

		// ------------------------------------------------------------------------------------------------------------------------ //
		// SCREEN ----------------------------------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		//		printf( "\n\n" );
		//
		//		for( unsigned int idx_storeLyap = 0; idx_storeLyap < (dim+numExtraSaves); idx_storeLyap++ )
		//			printf( "Mz_Lyap[%d][%d] = %.6f\n", idxCounterControlParameters, idx_storeLyap, Mz_Lyap[idxCounterControlParameters][idx_storeLyap] ); // screen - debug
		//
		//		printf( "\n" );


		//* *********************************************************************************************************************** */
		/* PRINT/SAVE DATA ********************************************************************************************************	*/
		//* *********************************************************************************************************************** */

		// ------------------------------------------------------------------------------------------------------------------------ //
		// Mz_Lyap ARRAY ---------------------------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		for( unsigned int idx_storeLyap = 0; idx_storeLyap < (dim+numExtraSaves); idx_storeLyap++ )
		{

			if(idx_storeLyap == 0)
				fprintf(fileData_Mz_Lyap, "%.6f", Mz_Lyap[idxCounterControlParameters][idx_storeLyap] );

			else if(idx_storeLyap == 1)
				fprintf(fileData_Mz_Lyap, ", %.6f", Mz_Lyap[idxCounterControlParameters][idx_storeLyap] );

			else if(idx_storeLyap == 2)
				fprintf(fileData_Mz_Lyap, ", %.6f", Mz_Lyap[idxCounterControlParameters][idx_storeLyap] );

			else
				fprintf(fileData_Mz_Lyap, ", %.12f", Mz_Lyap[idxCounterControlParameters][idx_storeLyap] );

		}

		fprintf(fileData_Mz_Lyap, "\n" );


		//* *********************************************************************************************************************** */
		/* PREPARE FOR THE NEXT ITERATION ***************************************************************************************** */
		//* *********************************************************************************************************************** */

		idxIterations = 0;

		//idxIntegra = 0;

		// ------------------------------------------------------------------------------------------------------------------------ //
		// UPDATE THE COUNTER ----------------------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		idxCounterControlParameters++;

		// ------------------------------------------------------------------------------------------------------------------------ //


	} // END - loop control parameter: gamma
	/* **************************************************************************************************************************** */

	/* **************************************************************************************************************************** */
	// CLOSE FILES **************************************************************************************************************** */
	/* **************************************************************************************************************************** */

	fclose( fileData_Mz_Lyap );


	/* **************************************************************************************************************************** */
	/* MEASURING THE TOTAL COMPUTATIONAL TIME ************************************************************************************* */
	/* **************************************************************************************************************************** */

	clock_t end = clock() ;

	double elapsed_time = (end-start)/(double)CLOCKS_PER_SEC ;

	printf( "\n" );

	printf( " Elapsed time [s]: %.12f \n", elapsed_time );


	/* **************************************************************************************************************************** */
	/* DISK - TOTAL COMPUTATIONAL TIME AND SOME OTHERS PARAMETERS ***************************************************************** */
	/* **************************************************************************************************************************** */

	fprintf(fileData_Header, "Control parameters: gamma\n");
	fprintf(fileData_Header, "\n");


	fprintf(fileData_Header, "nIncControlParameter1 = %.6f\n", nIncControlParameter1);
	fprintf(fileData_Header, "\n");


	fprintf(fileData_Header, "vGamma_min = %.6f\n", vGamma_min);
	fprintf(fileData_Header, "vGamma_max = %.6f\n", vGamma_max);
	fprintf(fileData_Header, "\n");


	fprintf(fileData_Header, "vGamma_length = %d\n", vGamma_length);
	fprintf(fileData_Header, "\n");


	fprintf(fileData_Header, "t_final = %.6f\n", t_final);
	fprintf(fileData_Header, "\n");

	fprintf(fileData_Header, "Elapsed time [s]: %.12f \n", elapsed_time );
	fprintf(fileData_Header, "Elapsed time [h]: %.12f \n", elapsed_time/3600.0 );

	fclose(fileData_Header);


	/* **************************************************************************************************************************** */
	/* IMPORTANT: FREE MEMORY ***************************************************************************************************** */
	/* **************************************************************************************************************************** */

	for ( unsigned int ii = 0; ii < nRows; ii++ )
		free( Mz_Lyap[ii] );

	free( Mz_Lyap );

	/* **************************************************************************************************************************** */

	printf("\n That's all!!!\n\n");

	return 0;

	/* **************************************************************************************************************************** */

}
