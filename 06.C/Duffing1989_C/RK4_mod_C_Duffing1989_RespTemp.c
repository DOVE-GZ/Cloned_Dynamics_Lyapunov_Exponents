/* ***********************************************************************************************************************************
 *
 * Name				: RK4_mod_C_Duffing1989_RespTemp.c
 * Author			: Filipe I. fazanaro
 * Copyright		: The code is released under the GPL v3 license.
 * Email			: filipe.fazanaro at gmail.com
 * Initial Version	: 30/Jan/2015
 * Last Update:		: 17/Jun/2020
 *
 * ***********************************************************************************************************************************
 * DESCRIPTION
 *
 * - Time response of the system defined by the Duffing forced oscillator dynamical model [1,2].
 *
 * - Employs the fourth-order Runge-Kutta integrator.
 *
 * - Employs separated functions for the dynamical systems, RK4 integration.
 *
 * ***********************************************************************************************************************************
 * OBSERVATIONS
 * - To be done:
 * 		 - Implement separated functions for the Gram-Schimidt Reorthonormalization.
 *
 * ***********************************************************************************************************************************
 * REFERENCES
 * [1] Parker and Chua (1989) Practical Numerical algorithms for Chaotic Systems. Springer-Verlag.
 *
 * [2] Guckenheimer, Holmes (2002) Nonlinear Oscillations, Dynamical Systems, and Bifurcations of Vector Fields.
 * Springer. 2nd edition.
 *
 * [3] http://mmae.iit.edu/shadden/LCS-tutorial/overview.html
 *
 * [4] Wolf, Swift, Swinney, Vastano (1985) Determining Lyapunov exponents from time series, Physica 16D, pp 285-317.
 * DOI:10.1016/0167-2789(85)90011-9
 *
 * [5] Soriano, Fazanaro, Suyama, JRO, Attux and Madrid (2012) A method for Lyapunov spectrum estimation using
 * cloned dynamics and its application toÂ the discontinuously-excited FitzHugh-Nagumo model. Nonlinear Dynamics,
 * vol 67, no 1, pp 413-424. DOI: 10.1007/s11071-011-9989-2.
 *
 * [6] https://www.google.com/search?q=error%3A+constant+value+is+not+known+CUDA&ie=UTF-8&sa=Search&channel=fe&client=browser-ubuntu&hl=en
 *
 * [7] http://stackoverflow.com/questions/9936376/how-to-defined-a-cuda-shared-memory-with-a-size-known-at-run-time
 *
 * [8] http://stackoverflow.com/questions/5531247/allocating-shared-memory/5531640#5531640
 *
 * [9] How to define square waves in C:
 * http://stackoverflow.com/questions/1073606/is-there-a-one-line-function-that-generates-a-triangle-wave
 *
 * [10] Most important characteristics of GPUs
 * http://developer.download.nvidia.com/compute/cuda/4_1/rel/toolkit/docs/online/group__CUDART__DEVICE_g5aa4f47938af8276f08074d09b7d520c.html
 *
 * [11] MEASURING TIME
 * http://ivanlife.wordpress.com/2011/05/09/time-cuda/
 * http://devblogs.nvidia.com/parallelforall/how-implement-performance-metrics-cuda-cc/
 *
 * [12] Pearson product-moment correlation coefficient
 * http://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient
 *
 * [13] http://stackoverflow.com/questions/13677566/malloc-a-2d-array-in-c
 *
 * [14] http://stackoverflow.com/questions/1970698/using-malloc-for-allocation-of-multi-dimensional-arrays-with-different-row-lengt
 *
 * ***********************************************************************************************************************************
 */


/* ******************************************************************************************************************************** */
// includes, system

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <time.h>

/* ******************************************************************************************************************************** */
/* DEFINITIONS ******************************************************************************************************************** */
/* ******************************************************************************************************************************** */

#define pi 3.141592653589793238462643383


/* ******************************************************************************************************************************** */
/* IMPORTANT DEFINITIONS: DYNAMICAL SYSTEMS DIMENSIONS **************************************************************************** */
/* ******************************************************************************************************************************** */

#define dim 3

#define dim_total dim

/* ******************************************************************************************************************************** */



/* ******************************************************************************************************************************** */
/* 												RUNGE KUTTA FOURTH ORDER INTEGRATOR													*/
/* ******************************************************************************************************************************** */
double odeRK4( double(*odefun)(double *, double, double *, double *), double * dydt, double h, double t0, double * y_init, double * vParameters, int nIntegra )
{

	// ============================================================================================================================ //
	// INITIALIZATIONS ============================================================================================================ //
	// ============================================================================================================================ //

	double Y0[dim_total];

	double k1[dim_total];
	double k2[dim_total];
	double k3[dim_total];
	double k4[dim_total];

	double t = t0;

	// ============================================================================================================================ //
	// MAIN LOOP ================================================================================================================== //
	// ============================================================================================================================ //
	for( unsigned int idx_Integra = 0; idx_Integra < nIntegra; idx_Integra++ )
	{

		// ------------------------------------------------------------------------------------------------------------------------ //
		// PARAMETER: k1 ---------------------------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		odefun( k1, t, y_init, vParameters );

		for( unsigned int jj = 0; jj < dim_total; jj++ )
		{

			k1[jj] = h*k1[jj];

			// Debug
			//printf("k1[%d] = %.6f\n", jj, k1[jj]);

		}

		//printf("\n");


		// ------------------------------------------------------------------------------------------------------------------------ //
		// PARAMETER: k2 ---------------------------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		for( unsigned int jj = 0; jj < dim_total; jj++ )
		{

			Y0[jj] = y_init[jj] + k1[jj]/2.0;

			// Debug
			//printf("Y0[%d] = %.6f\n", jj, Y0[jj]);

		}

		//printf("\n");


		odefun( k2, t, Y0, vParameters );

		for( unsigned int jj = 0; jj < dim_total; jj++ )
		{

			k2[jj] = h*k2[jj];

			// Debug
			//printf("k2[%d] = %.6f\n", jj, k2[jj]);

		}

		//printf("\n");



		// ------------------------------------------------------------------------------------------------------------------------ //
		// PARAMETER: k3 ---------------------------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		for( unsigned int jj = 0; jj < dim_total; jj++ )
		{

			Y0[jj] = y_init[jj] + k2[jj]/2.0;

			// Debug
			//printf("Y0[%d] = %.6f\n", jj, Y0[jj]);

		}

		//printf("\n");


		odefun( k3, t, Y0, vParameters );

		for( unsigned int jj = 0; jj < dim_total; jj++ )
		{

			k3[jj] = h*k3[jj];

			// Debug
			//printf("k3[%d] = %.6f\n", jj, k3[jj]);

		}

		//printf("\n");


		// ------------------------------------------------------------------------------------------------------------------------ //
		// PARAMETER: k4 ---------------------------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		for( unsigned int jj = 0; jj < dim_total; jj++ )
		{

			Y0[jj] = y_init[jj] + k3[jj];

			// Debug
			//printf("Y0[%d] = %.6f\n", jj, Y0[jj]);

		}

		//printf("\n");


		odefun( k4, t, Y0, vParameters );

		for( unsigned int jj = 0; jj < dim_total; jj++ )
		{

			k4[jj] = h*k4[jj];

			// Debug
			//printf("k4[%d] = %.6f\n", jj, k4[jj]);

		}

		//printf("\n");


		// ------------------------------------------------------------------------------------------------------------------------ //
		// UPDATE THE INITIAL CONDITIONS FOR THE NEXT ITERATION ----------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		for( unsigned int jj = 0; jj < dim_total; jj++ )
		{

			y_init[jj] = y_init[jj] + (1/6.0)*( k1[jj] + 2.0*k2[jj] + 2.0*k3[jj] + k4[jj] );

			// Debug
			//printf("y_init[%d] = %.6f\n", jj, y_init[jj]);
			//printf("[%.6f]", y_init[jj]);

		}

		//printf("\n");


		// ------------------------------------------------------------------------------------------------------------------------ //
		// UPDATE THE TIME ------------------------------------------------------------------------------------------------ //
		// ------------------------------------------------------------------------------------------------------------------------ //

		// Debug
		//printf("t = %.6f\n\n", t);

		t += h;

		// Debug
		//printf("t = %.6f\n\n", t);


	} // END MAIN LOOP
	// ============================================================================================================================ //


	// ============================================================================================================================ //
	// RETURN THE INTEGRAION RESULTS ============================================================================================== //
	// ============================================================================================================================ //
	for( unsigned int jj = 0; jj < dim_total; jj++ )
	{

		dydt[jj] = y_init[jj];

		// Debug
		//printf("y_init[%d] = %.6f\n", jj, y_init[jj]);
		//printf("[%.6f]", y_init[jj]);

	}

	//printf("\n");
	// ============================================================================================================================ //

	return 0;

	// ============================================================================================================================ //

}
/* ******************************************************************************************************************************** */



/* ******************************************************************************************************************************** */
/* 															ODEFUN																	*/
/* ******************************************************************************************************************************** */
double odefun_Duffing1989( double * dydt, double t0, double * y_init, double * vParameters )
{

	// ============================================================================================================================ //
	// PARAMETERS ================================================================================================================= //
	// ============================================================================================================================ //

	double
		epsilon = vParameters[0],
		gamma   = vParameters[1],
		omega   = vParameters[2];


	// ============================================================================================================================ //
	// INITIAL CONDITIONS ========================================================================================================= //
	// ============================================================================================================================ //

	double
		y10 = y_init[0],
		y20 = y_init[1],
		y30 = y_init[2];


	// ============================================================================================================================ //
	// DYNAMIC MODEL ============================================================================================================== //
	// ============================================================================================================================ //

	// ----------------------------------------------------------------------- //
	// DYNAMICAL SYSTEM ------------------------------------------------------ //
	// ----------------------------------------------------------------------- //

	dydt[0] = y20;
	dydt[1] = y10 - pow(y10,3) - epsilon*y20 + gamma*cos( omega*y30 );
	dydt[2] = 1.0;


	// ============================================================================================================================ //

	return 0;

	// ============================================================================================================================ //


}
/* ******************************************************************************************************************************** */






/* ******************************************************************************************************************************** */
/* ******************************************************************************************************************************** */
/* 															MAIN FUNCTION															*/
/* ******************************************************************************************************************************** */
/* ******************************************************************************************************************************** */
int main()
{

	/* **************************************************************************************************************************** */
	/* AUX ************************************************************************************************************************ */
	/* **************************************************************************************************************************** */

	int aux_counter = 0;

	int aux_index;


	/* **************************************************************************************************************************** */
	/* PARAMETERS ***************************************************************************************************************** */
	/* **************************************************************************************************************************** */

	const double
		epsilon = 0.22,
		gamma   = 0.3,
		omega   = 1.0;


	/* **************************************************************************************************************************** */
	/* VECTOR PARAMETER *********************************************************************************************************** */
	/* **************************************************************************************************************************** */

	double vParameters[] = { epsilon, gamma, omega };


	/* **************************************************************************************************************************** */
	/* INITIAL CONDITIONS OF THE DYNAMICAL SYSTEMS ******************************************************************************** */
	/* **************************************************************************************************************************** */

	double
		vX0 = 1.0,
		vY0 = 1.0,
		vZ0 = 0.0;


	double y_init[] = { vX0, vY0, vZ0 };


	/* **************************************************************************************************************************** */
	/* INTEGRATION PARAMETERS ***************************************************************************************************** */
	/* **************************************************************************************************************************** */

	// Initial time
	const double t_init = 0.0;

	// Final time
	const double t_final = 2000.0;

	// Transient
	const double t_trans = 1000.0;

	// Time step
	const double h = 0.01;


	// Transient index
	const int index_trans = round( t_trans / h );


	// Maximum iteration number
	const int nMaxItera = round( (t_final - t_init) / h );
	//printf("\n nMaxItera = %d\n", nMaxItera);
	printf("\n nMaxItera per combination = %d\n", nMaxItera);

	printf("\n\n");


	/* **************************************************************************************************************************** */
	/* MEASURING THE TOTAL COMPUTATIONAL TIME - BEGINS **************************************************************************** */
	/* **************************************************************************************************************************** */

	clock_t start = clock() ;


	/* **************************************************************************************************************************** */
	/* INTEGRATION **************************************************************************************************************** */
	/* **************************************************************************************************************************** */

	// ---------------------------------------------------------------------------------------------------------------------------- //
	// MEMORY ALLOCATION: STATE --------------------------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	double dydt[dim_total];


	// ---------------------------------------------------------------------------------------------------------------------------- //

	odeRK4( odefun_Duffing1989, dydt, h, t_init, y_init, vParameters, nMaxItera );

	// ---------------------------------------------------------------------------------------------------------------------------- //

	// DEBUG
	for( unsigned int jj = 0; jj < dim_total; jj++ )
	{
		//printf( "dydt[%d] = %.6f\n", jj, dydt[jj] );
		printf( "[%.12f]", dydt[jj] );
	}

	printf("\n");

	// ---------------------------------------------------------------------------------------------------------------------------- //


	/* **************************************************************************************************************************** */
	/* MEASURING THE TOTAL COMPUTATIONAL TIME ************************************************************************************* */
	/* **************************************************************************************************************************** */

	clock_t end = clock() ;

	double elapsed_time = (end-start)/(double)CLOCKS_PER_SEC ;

	printf( "\n" );

	printf( " Elapsed time [s]: %.12f \n", elapsed_time );


	/* **************************************************************************************************************************** */

	printf( "\n That's all!!!\n\n" );

	return 0;

	/* **************************************************************************************************************************** */

}
