/* ***********************************************************************************************************************************
 *
 * Name				: RK4_mod_C_Duffing1989_ClDyn.c
 * Author			: Filipe I. fazanaro
 * Copyright		: The code is released under the GPL v3 license.
 * Email			: filipe.fazanaro at gmail.com
 * Initial Version	: 30/Jan/2015
 * Last Update:		: 17/Jun/2020
 *
 * ***********************************************************************************************************************************
 * DESCRIPTION
 *
 * - Calculation of the Lyapunov global exponents - using the Cloned Dynamics approach - for the forced Duffing
 * oscillator dynamical system [1,2].
 *
 * - Employs the fourth-order Runge-Kutta integrator.
 *
 * - Employs separated functions for the dynamical systems, RK4 integration.
 *
 * ***********************************************************************************************************************************
 * OBSERVATIONS
 * - To be done:
 * 		 - Implement separated functions for the Gram-Schimidt Reorthonormalization.
 *
 * ***********************************************************************************************************************************
 * REFERENCES
 * [1] Parker and Chua (1989) Practical Numerical algorithms for Chaotic Systems. Springer-Verlag.
 *
 * [2] Guckenheimer, Holmes (2002) Nonlinear Oscillations, Dynamical Systems, and Bifurcations of Vector Fields.
 * Springer. 2nd edition.
 *
 * [3] http://mmae.iit.edu/shadden/LCS-tutorial/overview.html
 *
 * [4] Wolf, Swift, Swinney, Vastano (1985) Determining Lyapunov exponents from time series, Physica 16D, pp 285-317.
 * DOI:10.1016/0167-2789(85)90011-9
 *
 * [5] Soriano, Fazanaro, Suyama, JRO, Attux and Madrid (2012) A method for Lyapunov spectrum estimation using
 * cloned dynamics and its application toÂ the discontinuously-excited FitzHugh-Nagumo model. Nonlinear Dynamics,
 * vol 67, no 1, pp 413-424. DOI: 10.1007/s11071-011-9989-2.
 *
 * [6] https://www.google.com/search?q=error%3A+constant+value+is+not+known+CUDA&ie=UTF-8&sa=Search&channel=fe&client=browser-ubuntu&hl=en
 *
 * [7] http://stackoverflow.com/questions/9936376/how-to-defined-a-cuda-shared-memory-with-a-size-known-at-run-time
 *
 * [8] http://stackoverflow.com/questions/5531247/allocating-shared-memory/5531640#5531640
 *
 * [9] How to define square waves in C:
 * http://stackoverflow.com/questions/1073606/is-there-a-one-line-function-that-generates-a-triangle-wave
 *
 * [10] Most important characteristics of GPUs
 * http://developer.download.nvidia.com/compute/cuda/4_1/rel/toolkit/docs/online/group__CUDART__DEVICE_g5aa4f47938af8276f08074d09b7d520c.html
 *
 * [11] MEASURING TIME
 * http://ivanlife.wordpress.com/2011/05/09/time-cuda/
 * http://devblogs.nvidia.com/parallelforall/how-implement-performance-metrics-cuda-cc/
 *
 * [12] Pearson product-moment correlation coefficient
 * http://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient
 *
 * [13] http://stackoverflow.com/questions/13677566/malloc-a-2d-array-in-c
 *
 * [14] http://stackoverflow.com/questions/1970698/using-malloc-for-allocation-of-multi-dimensional-arrays-with-different-row-lengt
 *
 * ***********************************************************************************************************************************
 */


/* ******************************************************************************************************************************** */
// includes, system

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <time.h>

/* ******************************************************************************************************************************** */
/* DEFINITIONS ******************************************************************************************************************** */
/* ******************************************************************************************************************************** */

#define pi 3.141592653589793238462643383


/* ******************************************************************************************************************************** */
/* IMPORTANT DEFINITIONS: DYNAMICAL SYSTEMS DIMENSIONS **************************************************************************** */
/* ******************************************************************************************************************************** */

#define dim 3

#define dim_total dim*(dim+1)

/* ******************************************************************************************************************************** */



/* ******************************************************************************************************************************** */
/* 												RUNGE KUTTA FOURTH ORDER INTEGRATOR													*/
/* ******************************************************************************************************************************** */
double odeRK4( double(*odefun)(double *, double, double *, double *), double * dydt, double h, double t0, double * y_init, double * vParameters, int nIntegra )
{

	// ============================================================================================================================ //
	// INITIALIZATIONS ============================================================================================================ //
	// ============================================================================================================================ //

	double Y0[dim_total];

	double k1[dim_total];
	double k2[dim_total];
	double k3[dim_total];
	double k4[dim_total];

	double t = t0;

	// ============================================================================================================================ //
	// MAIN LOOP ================================================================================================================== //
	// ============================================================================================================================ //
	for( unsigned int idx_Integra = 0; idx_Integra < nIntegra; idx_Integra++ )
	{

		// ------------------------------------------------------------------------------------------------------------------------ //
		// PARAMETER: k1 ---------------------------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		odefun( k1, t, y_init, vParameters );

		for( unsigned int jj = 0; jj < dim_total; jj++ )
		{

			k1[jj] = h*k1[jj];

			// Debug
			//printf("k1[%d] = %.6f\n", jj, k1[jj]);

		}

		//printf("\n");


		// ------------------------------------------------------------------------------------------------------------------------ //
		// PARAMETER: k2 ---------------------------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		for( unsigned int jj = 0; jj < dim_total; jj++ )
		{

			Y0[jj] = y_init[jj] + k1[jj]/2.0;

			// Debug
			//printf("Y0[%d] = %.6f\n", jj, Y0[jj]);

		}

		//printf("\n");


		odefun( k2, t, Y0, vParameters );

		for( unsigned int jj = 0; jj < dim_total; jj++ )
		{

			k2[jj] = h*k2[jj];

			// Debug
			//printf("k2[%d] = %.6f\n", jj, k2[jj]);

		}

		//printf("\n");



		// ------------------------------------------------------------------------------------------------------------------------ //
		// PARAMETER: k3 ---------------------------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		for( unsigned int jj = 0; jj < dim_total; jj++ )
		{

			Y0[jj] = y_init[jj] + k2[jj]/2.0;

			// Debug
			//printf("Y0[%d] = %.6f\n", jj, Y0[jj]);

		}

		//printf("\n");


		odefun( k3, t, Y0, vParameters );

		for( unsigned int jj = 0; jj < dim_total; jj++ )
		{

			k3[jj] = h*k3[jj];

			// Debug
			//printf("k3[%d] = %.6f\n", jj, k3[jj]);

		}

		//printf("\n");


		// ------------------------------------------------------------------------------------------------------------------------ //
		// PARAMETER: k4 ---------------------------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		for( unsigned int jj = 0; jj < dim_total; jj++ )
		{

			Y0[jj] = y_init[jj] + k3[jj];

			// Debug
			//printf("Y0[%d] = %.6f\n", jj, Y0[jj]);

		}

		//printf("\n");


		odefun( k4, t, Y0, vParameters );

		for( unsigned int jj = 0; jj < dim_total; jj++ )
		{

			k4[jj] = h*k4[jj];

			// Debug
			//printf("k4[%d] = %.6f\n", jj, k4[jj]);

		}

		//printf("\n");


		// ------------------------------------------------------------------------------------------------------------------------ //
		// UPDATE THE INITIAL CONDITIONS FOR THE NEXT ITERATION ----------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		for( unsigned int jj = 0; jj < dim_total; jj++ )
		{

			y_init[jj] = y_init[jj] + (1/6.0)*( k1[jj] + 2.0*k2[jj] + 2.0*k3[jj] + k4[jj] );

			// Debug
			//printf("y_init[%d] = %.6f\n", jj, y_init[jj]);
			//printf("[%.6f]", y_init[jj]);

		}

		//printf("\n");


		// ------------------------------------------------------------------------------------------------------------------------ //
		// UPDATE THE TIME ------------------------------------------------------------------------------------------------ //
		// ------------------------------------------------------------------------------------------------------------------------ //

		// Debug
		//printf("t = %.6f\n\n", t);

		t += h;

		// Debug
		//printf("t = %.6f\n\n", t);


	} // END MAIN LOOP
	// ============================================================================================================================ //


	// ============================================================================================================================ //
	// RETURN THE INTEGRAION RESULTS ============================================================================================== //
	// ============================================================================================================================ //
	for( unsigned int jj = 0; jj < dim_total; jj++ )
	{

		dydt[jj] = y_init[jj];

		// Debug
		//printf("y_init[%d] = %.6f\n", jj, y_init[jj]);
		//printf("[%.6f]", y_init[jj]);

	}

	//printf("\n");
	// ============================================================================================================================ //
	
	return 0;

	// ============================================================================================================================ //

}
/* ******************************************************************************************************************************** */



/* ******************************************************************************************************************************** */
/* 															ODEFUN																	*/
/* ******************************************************************************************************************************** */
double odefun_Duffing1989_ClDyn( double * dydt, double t0, double * y_init, double * vParameters )
{

	// ============================================================================================================================ //
	// PARAMETERS ================================================================================================================= //
	// ============================================================================================================================ //

	double
		epsilon = vParameters[0],
		gamma   = vParameters[1],
		omega   = vParameters[2];


	// ============================================================================================================================ //
	// INITIAL CONDITIONS ========================================================================================================= //
	// ============================================================================================================================ //

	// DYNAMIC MODEL - FIDUCIAL

	double
		y10 = y_init[0],
		y20 = y_init[1],
		y30 = y_init[2];


	// DYNAMIC MODEL - CLONES

	double
		y40 = y_init[3],
		y50 = y_init[4],
		y60 = y_init[5];

	double
		y70 = y_init[6],
		y80 = y_init[7],
		y90 = y_init[8];

	double
		y100 = y_init[9],
		y110 = y_init[10],
		y120 = y_init[11];


	// ============================================================================================================================ //
	// DYNAMIC MODEL ============================================================================================================== //
	// ============================================================================================================================ //

	// ----------------------------------------------------------------------- //
	// DYNAMICAL SYSTEM - ORIGINAL (or FIDUCIAL) ----------------------------- //
	// ----------------------------------------------------------------------- //

	dydt[0] = y20;
	dydt[1] = y10 - pow(y10,3) - epsilon*y20 + gamma*cos( omega*y30 );
	dydt[2] = 1.0;


	// ----------------------------------------------------------------------- //
	// DYNAMICAL SYSTEM - CLONES --------------------------------------------- //
	// ----------------------------------------------------------------------- //

	dydt[3] = y70;
	dydt[4] = y80;
	dydt[5] = y90;

	dydt[6] = y40 - pow(y40,3) - epsilon*y70 + gamma*cos( omega*y100 );
	dydt[7] = y50 - pow(y50,3) - epsilon*y80 + gamma*cos( omega*y110 );
	dydt[8] = y60 - pow(y60,3) - epsilon*y90 + gamma*cos( omega*y120 );

	dydt[9]  = 1.0;
	dydt[10] = 1.0;
	dydt[11] = 1.0;

	// ============================================================================================================================ //
	
	
	return 0;


}
/* ******************************************************************************************************************************** */






/* ******************************************************************************************************************************** */
/* ******************************************************************************************************************************** */
/* 															MAIN FUNCTION															*/
/* ******************************************************************************************************************************** */
/* ******************************************************************************************************************************** */
int main()
{

	/* **************************************************************************************************************************** */
	/* AUX ************************************************************************************************************************ */
	/* **************************************************************************************************************************** */

	unsigned int idxIterations = 0;

	unsigned int idxIntegra = 0;

	unsigned int aux_counter = 0;


	/* **************************************************************************************************************************** */
	/* PARAMETERS ***************************************************************************************************************** */
	/* **************************************************************************************************************************** */

	const double
		epsilon = 0.25,
		gamma   = 0.3,
		omega   = 1.0;


	/* **************************************************************************************************************************** */
	/* VECTOR PARAMETER *********************************************************************************************************** */
	/* **************************************************************************************************************************** */

	double vParameters[] = { epsilon, gamma, omega };


	/* **************************************************************************************************************************** */
	/* INITIAL CONDITIONS OF THE DYNAMICAL AND THE CLONED SYSTEMS ***************************************************************** */
	/* **************************************************************************************************************************** */

	// ---------------------------------------------------------------------------------------------------------------------------- //
	// CLONED DYNAMICAL SYSTEM PERTURBATION - SEE [5] ----------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	const double delta = 0.0001;


	// ---------------------------------------------------------------------------------------------------------------------------- //
	// ORIGINAL SYSTEM ------------------------------------------------------------------------------------------------------------ //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	double
		vX0 = 1.0,
		vY0 = 1.0,
		vZ0 = 0.0;


	double y_init_orig[] = { vX0, vY0, vZ0 };


	// ---------------------------------------------------------------------------------------------------------------------------- //
	// PERTURBATION MATRIX -------------------------------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	// IDENTITY MATRIX
	double mIdentity[dim][dim];

	for ( unsigned int idxRows = 0; idxRows < dim; idxRows++)
		for ( unsigned int idxCols = 0; idxCols < dim; idxCols++)
		{

			if ( idxCols == idxRows )
				mIdentity[idxRows][idxCols] = delta;
			else
				mIdentity[idxRows][idxCols] = 0.0;


			// Debug
			//printf( "mIdentity[%d][%d] = %.4f\n", idxRows, idxCols, mIdentity[idxRows][idxCols] );

		}


	// 2D array to 1D array transformation

	int HEIGHT = dim;
	int WIDTH  = dim;

	double y_init_perturb[HEIGHT * WIDTH];

	for ( unsigned int idxHEIGHT = 0; idxHEIGHT < HEIGHT; idxHEIGHT++)
	{

		for ( unsigned int idxWIDTH = 0; idxWIDTH < WIDTH; idxWIDTH++)
		{

			y_init_perturb[idxHEIGHT*WIDTH + idxWIDTH]= mIdentity[idxHEIGHT][idxWIDTH] + y_init_orig[idxHEIGHT];

			// Debug
			//printf( "[y_init_perturb[%d] = %.4f]", (idxHEIGHT*WIDTH + idxWIDTH), y_init_perturb[idxHEIGHT*WIDTH + idxWIDTH] );

		}

		//printf( "\n" );

	}

	//printf( "\n\n" );



	// ---------------------------------------------------------------------------------------------------------------------------- //
	// COMPLETE SYSTEM ------------------------------------------------------------------------------------------------------------ //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	double y_init[dim_total];


	for( unsigned int ii = 0; ii < dim_total; ii++){
		if( ii < dim ){

			y_init[ii] = y_init_orig[aux_counter];

			aux_counter++;

		}else{

			if( ii == (dim) )
				aux_counter = 0;

			y_init[ii] = y_init_perturb[aux_counter];

			aux_counter++;

		}

		// ------------------------------------------------------------------ //
		// INITIAL CONDITIONS DEBUG
		// ------------------------------------------------------------------ //

		//printf("y_init[%d] = %.6f\n", ii, y_init[ii]);

		// ------------------------------------------------------------------ //

	}

	//printf("\n\n");


	/* **************************************************************************************************************************** */
	/* INTEGRATION PARAMETERS ***************************************************************************************************** */
	/* **************************************************************************************************************************** */

	// Aux
	double t_aux = 0.0;


	// Initial time
	const double t_init = 0.0;

	// Final time
	const double t_final = 1000.0;

	// Gram-Schimidt reorthonormalization time interval
	//   - See [5] for further details related to how to change this value.
	const double t_gsr = 0.50;


	// Time step
	const double h = 0.01;


	// Maximum iteration number
	const int nMaxItera = round( (t_final - t_init) / h );
	//printf("\n nMaxItera = %d\n", nMaxItera);
	printf("\n nMaxItera per combination = %d\n", nMaxItera);


	// Defines how many iterations of the RK4 algorithm will be executed every iteration
	const int nIntegra = ( t_gsr / h );
	printf("\n nIntegra = %d\n", nIntegra);

	printf("\n\n");


	/* **************************************************************************************************************************** */
	/* GRAM-SCHIMIDT REORTHONORMALIZATION ***************************************************************************************** */
	/* **************************************************************************************************************************** */

	double vk[dim][dim];
	double uk[dim][dim];

	double deltax[dim][dim];


	for( unsigned int ii = 0; ii < dim; ii++ )
	{
		for( unsigned int jj = 0; jj < dim; jj++ )
		{
			vk[ii][jj] = 0.0;
			uk[ii][jj] = 0.0;

			deltax[ii][jj] = 0.0;
		}
	}


	/* **************************************************************************************************************************** */
	/* SOME INITIALIZATIONS ******************************************************************************************************* */
	/* **************************************************************************************************************************** */

	double LyapSoma[dim][nMaxItera+1];
	double Lyap[dim][nMaxItera+1];

	double Time[nMaxItera];


	for( unsigned int ii = 0; ii < dim; ii++ )
	{
		for( unsigned int jj = 0; jj < nMaxItera; jj++)
		{
			LyapSoma[ii][jj] = 0.0;
			Lyap[ii][jj] = 0.0;
		}
	}
	//	LyapSoma[0][0] = 0.0;
	//	LyapSoma[1][0] = 0.0;
	//	LyapSoma[2][0] = 0.0;
	//
	//	Lyap[0][0] = 0.0;
	//	Lyap[1][0] = 0.0;
	//	Lyap[2][0] = 0.0;

	Time[0] = 0.0;


	/* **************************************************************************************************************************** */
	/* POINTERS USED TO SAVA DATA ON DISK ***************************************************************************************** */
	/* **************************************************************************************************************************** */

	FILE *fileDataLyap = fopen("data_C_RK4_mod_Duffing1989_Lyap_ClDyn.txt", "w+");

	// ------------------------------------------------------------------------------------ //

	if (fileDataLyap == NULL)
	{
		printf(" Error opening the file 'data_C_RK4_mod_Duffing1989_Lyap_ClDyn.txt' !\n");
		exit(1);
	}

	// ------------------------------------------------------------------------------------ //


	/* **************************************************************************************************************************** */
	/* MEASURING THE TOTAL COMPUTATIONAL TIME - BEGINS **************************************************************************** */
	/* **************************************************************************************************************************** */

	clock_t start = clock() ;


	/* **************************************************************************************************************************** */
	/* DYNAMICAL SYSTEM INTEGRATION *********************************************************************************************** */
	/* **************************************************************************************************************************** */

	while (idxIterations < nMaxItera) {

		/* ======================================================================================================================== */
		/* DYNAMICAL SYSTEM INTEGRATION =========================================================================================== */
		/* ======================================================================================================================== */

		double dydt[dim_total];


		odeRK4( odefun_Duffing1989_ClDyn, dydt, h, t_init, y_init, vParameters, nIntegra );


		/* ======================================================================================================================== */
		/* UPDATE TIME AUX ======================================================================================================== */
		/* ======================================================================================================================== */

		t_aux = t_aux + t_gsr;


		/* ======================================================================================================================== */
		/* DIFERENCE STATE VECTORS ================================================================================================ */
		/* ======================================================================================================================== */

		// ------------------------------------------------------------------------------------ //
		// THE DUMMY WAY ---------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------ //
		//		deltax[0][0] = dydt[0] - dydt[2];
		//		deltax[0][1] = dydt[0] - dydt[3];
		//
		//		deltax[1][0] = dydt[1] - dydt[4];
		//		deltax[1][1] = dydt[1] - dydt[5];


		// ------------------------------------------------------------------------------------ //
		// TRYING A BETTER WAY ---------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------ //

		for( unsigned int idxRows = 0; idxRows < dim; idxRows++ )
		{
			for( unsigned int idxCols = 0; idxCols < dim; idxCols++ )
			{
				deltax[idxRows][idxCols] = dydt[idxRows] - dydt[dim*(idxRows+1)+idxCols];
			}
		}


		// ------------------------------------------------------------------------------------ //
		// DEBUG - SCREEN --------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------ //

		//		printf( "\n" );
		//
		//		for( unsigned int ii = 0; ii < dim; ii++ )
		//		{
		//			for( unsigned int jj = 0; jj < dim; jj++ )
		//			{
		//				//printf( "[deltax[%d][%d] = %.6f]", ii, jj, deltax[ii][jj] );
		//				printf( "[%.12f]", deltax[ii][jj] );
		//			}
		//			printf( "\n" );
		//		}
		//
		//		printf( "\n" );


		/* ======================================================================================================================== */
		/* GRAM-SCHIMIDT REORTHONORMALIZATION ===================================================================================== */
		/* ======================================================================================================================== */

		// ------------------------------------------------------------------------------------ //
		// THE DUMMY WAY ---------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------ //

		double pdi1 = 0.0;
		double pdi2 = 0.0;

		double Norm1 = 0.0;
		double Norm2 = 0.0;
		double Norm3 = 0.0;


		// EXPONENT Lyap1
		vk[0][0] = deltax[0][0];
		vk[1][0] = deltax[1][0];
		vk[2][0] = deltax[2][0];

		Norm1 = sqrt( pow(vk[0][0],2)+pow(vk[1][0],2)+pow(vk[2][0],2) );

		uk[0][0] = vk[0][0]/Norm1;
		uk[1][0] = vk[1][0]/Norm1;
		uk[2][0] = vk[2][0]/Norm1;


		// EXPONENT Lyap2
		// 	- Remember: the numerator represents a dot product
		//	- Remember: the denumerator represents the square of each element of the vector
		pdi1 = ( uk[0][0]*deltax[0][1]+uk[1][0]*deltax[1][1]+uk[2][0]*deltax[2][1] ) / ( uk[0][0]*uk[0][0]+uk[1][0]*uk[1][0]+uk[2][0]*uk[2][0] );

		vk[0][1] = deltax[0][1] - pdi1 * uk[0][0];
		vk[1][1] = deltax[1][1] - pdi1 * uk[1][0];
		vk[2][1] = deltax[2][1] - pdi1 * uk[2][0];

		Norm2 = sqrt( pow(vk[0][1],2)+pow(vk[1][1],2)+pow(vk[2][1],2) );

		uk[0][1] = vk[0][1]/Norm2;
		uk[1][1] = vk[1][1]/Norm2;
		uk[2][1] = vk[2][1]/Norm2;


		// EXPONENT Lyap3
		pdi1 = ( uk[0][0]*deltax[0][2]+uk[1][0]*deltax[1][2]+uk[2][0]*deltax[2][2] ) / ( uk[0][0]*uk[0][0]+uk[1][0]*uk[1][0]+uk[2][0]*uk[2][0] );
		pdi2 = ( uk[0][1]*deltax[0][2]+uk[1][1]*deltax[1][2]+uk[2][1]*deltax[2][2] ) / ( uk[0][1]*uk[0][1]+uk[1][1]*uk[1][1]+uk[2][1]*uk[2][1] );

		vk[0][2] = deltax[0][2] - pdi1*uk[0][0] - pdi2*uk[0][1];
		vk[1][2] = deltax[1][2] - pdi1*uk[1][0] - pdi2*uk[1][1];
		vk[2][2] = deltax[2][2] - pdi1*uk[2][0] - pdi2*uk[2][1];

		Norm3 = sqrt( pow(vk[0][2],2)+pow(vk[1][2],2)+pow(vk[2][2],2) );

		uk[0][2] = vk[0][2]/Norm3;
		uk[1][2] = vk[1][2]/Norm3;
		uk[2][2] = vk[2][2]/Norm3;


		//		// ------------------------------------------------------------------------------------ //
		//		// DEBUG - SCREEN - vk ---------------------------------------------------------------- //
		//		// ------------------------------------------------------------------------------------ //
		//
		//		printf( "\n" );
		//
		//		for( unsigned int ii = 0; ii < dim; ii++ )
		//		{
		//			for( unsigned int jj=0; jj < dim; jj++ )
		//			{
		//				//printf( "| vk[%d][%d] = %.12f |", ii, jj, vk[ii][jj] );
		//				printf( "[%.12f]", vk[ii][jj] );
		//			}
		//
		//			//printf( "|\n" );
		//			printf( "\n" );
		//		}
		//
		//		printf( "\n" );
		//
		//
		//		// ------------------------------------------------------------------------------------ //
		//		// SCREEN - uk ------------------------------------------------------------------------ //
		//		// ------------------------------------------------------------------------------------ //
		//
		//		printf( "\n" );
		//
		//		for( unsigned int ii = 0; ii < dim; ii++ )
		//		{
		//			for( unsigned int jj=0; jj < dim; jj++ )
		//			{
		//				//printf( "| uk[%d][%d] = %.12f |", ii, jj, uk[ii][jj] );
		//				printf( "[%.12f]", uk[ii][jj] );
		//			}
		//
		//			//printf( "|\n" );
		//			printf( "\n" );
		//		}
		//
		//		printf( "\n" );


		/* ======================================================================================================================== */
		/* LYAPUNOV EXPONENTS CALCULATION ========================================================================================= */
		/* ======================================================================================================================== */

		// ------------------------------------------------------------------------------------ //
		// LYAPUNOV EXPONENTS SUMMATION ------------------------------------------------------- //
		// ------------------------------------------------------------------------------------ //

		LyapSoma[0][idxIterations+1] = LyapSoma[0][idxIterations] + log( Norm1/delta );
		LyapSoma[1][idxIterations+1] = LyapSoma[1][idxIterations] + log( Norm2/delta );
		LyapSoma[2][idxIterations+1] = LyapSoma[2][idxIterations] + log( Norm3/delta );


		// ------------------------------------------------------------------------------------ //
		// GLOBAL LYAPUNOV EXPONENTS ---------------------------------------------------------- //
		// ------------------------------------------------------------------------------------ //

		Lyap[0][idxIterations+1] = (1.0/(t_aux-t_init))*LyapSoma[0][idxIterations+1];
		Lyap[1][idxIterations+1] = (1.0/(t_aux-t_init))*LyapSoma[1][idxIterations+1];
		Lyap[2][idxIterations+1] = (1.0/(t_aux-t_init))*LyapSoma[2][idxIterations+1];


		// ------------------------------------------------------------------------------------ //
		// SCREEN ----------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------ //

		//		printf( "\n" );
		//
		//		for( unsigned int ii = 0; ii < dim; ii++ )
		//		{
		//			for( unsigned int jj = 0; jj <= (idxIterations+1); jj++ )
		//			{
		//				//printf( "| LyapSoma[%d][%d] = %.8f | ", ii, jj, LyapSoma[ii][jj] );
		//				printf( "[%.12f]", LyapSoma[ii][jj] );
		//			}
		//			printf( "\n" );
		//		}
		//
		//		printf( "\n" );
		//
		//

		//		printf( "\n" );
		//
		//		for( unsigned int ii = 0; ii < dim; ii++ )
		//		{
		//			for( unsigned int jj = 0; jj <= (idxIterations+1); jj++ )
		//			{
		//				//printf( "| Lyap[%d][%d] = %.8f | ", ii, jj, Lyap[ii][jj] );
		//				printf( "[%.12f]", Lyap[ii][jj] );
		//			}
		//			printf( "\n" );
		//		}
		//
		//		printf( "\n" );


		/* ======================================================================================================================== */
		/* PREPARE FOR THE NEXT ITERATION ========================================================================================= */
		/* ======================================================================================================================== */

		// ------------------------------------------------------------------------------------ //
		// INITIAL CONDITIONS ----------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------ //

		// ORIGINAL SYSTEM
		y_init[0] = dydt[0];
		y_init[1] = dydt[1];
		y_init[2] = dydt[2];

		// CLONES
		y_init[3] = dydt[0] + delta*uk[0][0];
		y_init[4] = dydt[0] + delta*uk[0][1];
		y_init[5] = dydt[0] + delta*uk[0][2];

		y_init[6] = dydt[1] + delta*uk[1][0];
		y_init[7] = dydt[1] + delta*uk[1][1];
		y_init[8] = dydt[1] + delta*uk[1][2];

		y_init[9]  = dydt[2] + delta*uk[2][0];
		y_init[10] = dydt[2] + delta*uk[2][1];
		y_init[11] = dydt[2] + delta*uk[2][2];

		// ------------------------------------------------------------------------------------ //

		Time[idxIterations+1] = t_aux;

		// ------------------------------------------------------------------------------------ //

		idxIterations++;

		idxIntegra = 0;

		// ------------------------------------------------------------------------------------ //

		/* ======================================================================================================================== */

	} // END - ITERATIONS


	/* **************************************************************************************************************************** */
	/* SCREEN - LYAPUNOV EXPONENTS OBTAINED AT THE END OF EACH ITERATION ********************************************************** */
	/* **************************************************************************************************************************** */

	//printf( "\n" );

	for( unsigned int ii = 0; ii < dim; ii++ ){
		printf("Lyap[%d] = %.12f\n", ii, Lyap[ii][idxIterations]);
	}

	printf( "\n" );


	/* **************************************************************************************************************************** */
	/* MEASURING THE TOTAL COMPUTATIONAL TIME ************************************************************************************* */
	/* **************************************************************************************************************************** */

	clock_t end = clock() ;

	double elapsed_time = (end-start)/(double)CLOCKS_PER_SEC ;

	printf( "\n" );

	printf( " Elapsed time [s]: %.12f \n", elapsed_time );


	/* **************************************************************************************************************************** */
	/* PRINT/SAVE DATA ************************************************************************************************************	*/
	/* **************************************************************************************************************************** */

	// ------------------------------------------------------------------------------------ //
	// LYAPUNOV EXPONENTS ----------------------------------------------------------------- //
	// ------------------------------------------------------------------------------------ //

	for( unsigned int ii = 0; ii <= nMaxItera; ii++ )
	{

		fprintf(fileDataLyap, "%d", ii);

		for( unsigned int jj = 0; jj < dim; jj++ )
		{
			fprintf(fileDataLyap, ", %.12f", Lyap[jj][ii] );
		}

		fprintf(fileDataLyap, "\n" );

	}


	// ------------------------------------------------------------------------------------ //
	// CLOSE FILES ------------------------------------------------------------------------ //
	// ------------------------------------------------------------------------------------ //

	fclose(fileDataLyap);


	/* **************************************************************************************************************************** */

	printf( "\n That's all!!!\n\n" );

	return 0;

	/* **************************************************************************************************************************** */

}
